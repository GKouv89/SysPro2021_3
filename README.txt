3η Εργασία Προγραμματισμού Συστήματος
Ονοματεπώνυμο: Γεωργία Κουτίβα
Αριθμός Μητρώου: 1115201700060

Οδηγίες μεταγλώττισης και εκτέλεσης:
    Μεταγλώττιση: make
    Εκτέλεση: όπως προδιαγράφεται στην εκφώνηση της εργασίας. Εναλλακτικά, μπορείτε να χρησιμοποιήσετε το Makefile.
    Αλλάζετε τις τιμές των μεταβλητών MONITORS, SOCKBUFSIZE, CYCLICBUFSIZE, BFSIZE, INPUT_DIR και NUMTHREADS και 
    εκτελείτε make_run

    Επιπλέον:
    make clean_log για απαλοιφή όλων των log files που έχουν παραχθεί
    make clean για απαλοιφή των 2 εκτελέσιμων και των περιεχομένων του φακέλου build.

Σχεδιαστικές επιλογές όσον αφορά το δικτυακό κομμάτι:
    Οι servers είναι τα monitorServers, δηλαδή εκεί γίνεται το bind και το accept του connection. Ο πατέρας στέλνει στα παιδιά
    το port number το οποίο ξεκινάει πάντα από το 7777 και αυξάνεται κατά ένα για κάθε ένα παιδί, και μετά κάνει connect σε αυτό
    το port. Ο server θα κάνει πρώτα το bind και accept και μετά θα προχωρήσει στις υπόλοιπες λειτουργίες του. Χρησιμοποιείται ένα 
    socket ανά παιδί, και επάνω από αυτό γράφεται πληροφορίες και προς τις δύο κατευθύνσεις.

Πρωτόκολλο επικοινωνίας: 
    Το πρωτόκολλο επικοινωνίας έχει μείνει ακριβώς ίδιο σε σχέση με της δεύτερης εργασίας. Συνοπτικά, η διεργασία που γράφει 
    γράφει το μήκος των δεδομένων που πρόκειται να αποστείλει (εκτός αν αυτό είναι γνωστό, π.χ. bloom filter size) και κατόπιν
    στέλνει τα δεδομένα και συνήθως (αλλά όχι πάντα) περιμένει μία επιβεβαίωση από την διεργασία που διαβάζει (αυτή είναι το γράψιμο του 1 στο socket).
    Εξαιρέσεις στο πρωτόκολλο είναι οι εξής:
        1) addVaccinationRecords: Καθώς αυτό υλοποιούταν μέσω σήματος στην προηγούμενη εργασία, και έτσι η διεργασία-παιδί
        δεν γνώριζε σε ποιον από τους καταλόγους που διαχειριζόταν προστέθηκαν τα νέα αρχεία, εξέταζε όλους τους φακέλους.
        Τώρα, ο γονιός λέει μέσω socket στο παιδί που διαχειρίζεται τον κατάλογο την εντολή newVaccs country, όπου country
        είναι η χώρα που ο χρήστης έχει δώσει μέσω του terminal. Έτσι, εξετάζει μόνο αυτόν τον φάκελο για νέα αρχεία.
        2) exit: Αντί για την χρήση σήματος, ο γονιός απλά στέλνει αυτούσιο σε όλες τις διεργασίες παιδιά το μήνυμα /exit\n.

Σχεδιαστικές επιλογές όσον αφορά το κομμάτι των threads/κυκλικού buffer:
    Ο κυκλικός buffer και οι συναρτήσεις place, obtain, produce, consume, addNewRecords και killThreadPool είναι βασισμένα στον κώδικα
    των διαφανειών http://cgi.di.uoa.gr/~mema/courses/k24/lectures/topic6-Threads.pdf. Το main thread φτιάχνει πρώτα τα worker threads,
    και κατόπιν μέσω της produce διαβάζει όλα τα arguments που αφορούν paths, και γεμίζει τον κυκλικό buffer. Με το που αδειάζει μία θέση,
    προσθέτει επόμενο αρχείο - δεν περιμένει να αδειάσει τελείως ο buffer. Παράλληλα, καταγράφει και τον αριθμό των αρχείων που έχει καταγράψει.
    Τα worker threads ξυπνούν με το που προστεθεί ένα αρχείο στον buffer. Αυτά είναι υπεύθυνα για την καταγραφή του αριθμού των αρχείων που έχουν καταναλώσει
    συνολικά, καθώς και για την καταγραφή των αρχείων που έχουν βρεθεί σε κάθε φάκελο (ώστε να γνωρίζει μία πιθανή κλήση της addVaccinationRecords από ποιο
    αρχείο να ξεκινήσει).  Οι κοινές δομές, δηλαδή τα bloom filters, τα hashmap με τους ιούς, πολίτες, χώρες, και τα skiplists, καθώς και η μεταβληγή
    filesConsumed προστατεύονται από τον σημαφόρο dataStructAccs. Όταν το producer thread ολοκληρώσει να διαβάζει τα αρχεία, περιμένει στην condition variable 
    allfiles_consumed έως ότου τα consumer threads καταναλώσουν όλα τα αρχεία τα οποία έχει προσθέσει στον buffer (μέχρις ότου η συνθήκη 
    filesProduced == filesConsumed γίνει αληθής). Όταν γίνει αληθής, το main thread μηδενίζει τις μεταβλητές filesProduced και filesConsumed, ώστε να είναι 
    έτοιμο για επόμενη 'παρτίδα' αρχείων (αυτή την φορά σε συγκεκριμένο φάκελο με το addVaccinationRecords). Αν κληθεί αυτή, τότε θα κληθεί η addNewRecords
    αντί για την produce, όμως η μόνη διαφορά είναι από που αντλεί αρχεία: εξακολουθεί να χρησιμοποιεί την place, και τα threads, τα οποία είναι ζωντανά αλλά 
    μπλοκαρισμένα μέχρι εκείνη την ώρα, εξακολουθούν να χρησιμοποιούν την obtain και την consume. Τα threads έχουν παραμείνει μπλοκαρισμένα μέχρι εκείνη την 
    ώρα παρά το γεγονός ότι το buffer είναι άδειο γιατί πέρα από το πλήθος αρχείων μέσα σε αυτό ελέγχουν αν τους έχει δοθεί εντολή να τερματίσουν μέσω της 
    μεταβλητής hasThreadFinished που τους δίνεται ως όρισμα (ένας ακέραιος για κάθε thread). Όταν το main thread προσθέσει τα καινούρια αρχεία, περιμένει πάλι
    στο condition variable allfiles_consumed και ξαναμηδενίζει αφού βγει από αυτό τις μεταβλητές filesProduced, filesConsumed. Για να τερματίσουν τα worker
    threads, αφού λάβει την exit το κύριο thread, καλεί την killThreadPool η οποία γράφει στο buffer τόσες φορές όσα threads υπάρχουν την λέξη END. Όταν ένα 
    thread κάνει obtain αυτή την λέξη γνωρίζει ότι ήρθε η ώρα να τερματίσει, θέτει την μεταβλητή hasThreadFinished σε αληθή, και επιστρέφει στην consume, 
    η οποία βλέποντας την μεταβλητή ίση με ένα τερματίζει το thread.